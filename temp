package Just_Forge_2D.SceneSystem;

import Just_Forge_2D.AnimationSystem.AnimationComponent;
import Just_Forge_2D.AssetPool.AssetPool;
import Just_Forge_2D.EditorSystem.EditorSystemManager;
import Just_Forge_2D.EntityComponentSystem.Components.Component;
import Just_Forge_2D.EntityComponentSystem.Components.SpriteComponent;
import Just_Forge_2D.EntityComponentSystem.Components.TransformComponent;
import Just_Forge_2D.EntityComponentSystem.GameObject;
import Just_Forge_2D.EventSystem.EventManager;
import Just_Forge_2D.InputSystem.Mouse;
import Just_Forge_2D.PhysicsSystem.PhysicsComponents.RigidBodyComponent;
import Just_Forge_2D.PhysicsSystem.PhysicsSystemManager;
import Just_Forge_2D.RenderingSystem.Renderer;
import Just_Forge_2D.Utils.Logger;

import java.util.*;

// - - - Abstract class for all the scenes
public class Scene
{
    // - - - Private Variables - - -

    // - - - Basic
    private Camera camera;
    private String savePath = "";
    protected boolean isRunning = false;

    // - - - ALl the objects
    private final Map<Integer, GameObject> gameObjectsById = new HashMap<>();
    private final Map<String, GameObject> gameObjectsByName = new HashMap<>();
    private final Set<GameObject> pendingObjects = new HashSet<>();

    // - - - Scene Rendering
    private final Renderer renderer;
    private final SceneScript script;

    // - - - saving and loading
    private final PhysicsSystemManager physics;

    private final String name;


    // - - - | Functions | - - -


    // - - - Now presenting: useful constructor
    public Scene(SceneScript INITIALIZER, String NAME)
    {
        this.script = INITIALIZER;
        this.physics = new PhysicsSystemManager(this, INITIALIZER.physicsWorld);
        this.renderer = INITIALIZER.renderer;
        this.isRunning = false;
        this.name = NAME;
    }


    // - - - Use the Scene - - -

    public void start()
    {
        Logger.FORGE_LOG_INFO("Starting Scene : " + this.script);

        for (GameObject go : gameObjectsById.values())
        {
            // - - - Register with renderer and physics if applicable
            if (this.renderer != null && go.hasComponent(SpriteComponent.class))
            {
                this.renderer.add(go);
            }
            if (this.physics != null && go.hasComponent(RigidBodyComponent.class))
            {
                this.physics.add(go);
            }

            // - - - Start the game object
            go.start();
        }

        isRunning = true;
        Logger.FORGE_LOG_INFO("Scene: " + this + " Started");
    }

    private void updateKernel(float DELTA_TIME)
    {
        this.camera.adjustProjection();

        // - - - Update objects and remove dead ones
        gameObjectsById.values().removeIf(go ->
        {
            go.update(DELTA_TIME);
            boolean isDead = go.isDead();
            if (isDead)
            {
                if (physics != null) physics.destroyGameObject(go);
                if (renderer != null) renderer.destroyGameObject(go);
                gameObjectsByName.remove(go.name);
            }
            return isDead;
        });

        // - - - Add pending objects to the active pool
        for (GameObject go : pendingObjects)
        {
            gameObjectsById.put(go.getUniqueID(), go);
            gameObjectsByName.put(go.name, go);
            go.start();
            if (renderer != null) renderer.add(go);
            if (physics != null) physics.add(go);
        }
        pendingObjects.clear();
    }

    public void update(float DELTA_TIME)
    {
        if (!this.isRunning) return;

        this.script.update(DELTA_TIME);
        if (this.physics != null) this.physics.update(DELTA_TIME);

        updateKernel(DELTA_TIME);

    }

    public void render(float DELTA_TIME)
    {
        if (this.renderer != null) this.renderer.render();
        this.script.render(DELTA_TIME);
    }

    public void init()
    {
        // - - -Set up the camera
        this.camera = Mouse.getWorldCamera();

        // - - - If not in release mode, add master game object
        if (!EditorSystemManager.isRelease)
        {
            addGameObject(SceneSystemManager.createMaster(this));
        }

        // - - -Register the camera as an observer
        EventManager.addObserver(this.camera);

        // - - - Set the save path if not already set
        if (this.savePath.isEmpty())
        {
            setSavePath(this.script.savePath);
        }

        // - - - Load resources specified by the script
        this.script.loadResources(this);

        // - - - Refresh textures for SpriteComponent and AnimationComponent
        for (GameObject gameObject : gameObjectsById.values())
        {
            SpriteComponent spriteComponent = gameObject.getComponent(SpriteComponent.class);
            if (spriteComponent != null && spriteComponent.getTexture() != null)
            {
                spriteComponent.setTexture(AssetPool.makeTexture(spriteComponent.getTexture().getFilepath()));
            }

            AnimationComponent animationComponent = gameObject.getComponent(AnimationComponent.class);
            if (animationComponent != null)
            {
                animationComponent.refreshTextures();
            }
        }

        // - - - Initialize script and log initialization
        this.script.init(this);
        Logger.FORGE_LOG_INFO("Scene: " + this.script + " Initialized");
    }



    // - - -  Game Objects - - -

    public GameObject createGameObject(String NAME)
    {
        GameObject go = new GameObject(NAME);
        go.addComponent(new TransformComponent());
        go.transform = go.getComponent(TransformComponent.class);
        return go;
    }

    public void addGameObject(GameObject gameObject)
    {
        if (isRunning)
        {
            pendingObjects.add(gameObject);
        }
        else
        {
            gameObjectsById.put(gameObject.getUniqueID(), gameObject);
            gameObjectsByName.put(gameObject.name, gameObject);
        }
    }


    public GameObject getGameObject(int GAME_OBJECT_ID)
    {
        return gameObjectsById.get(GAME_OBJECT_ID);
    }

    public GameObject getGameObject(String NAME)
    {
        GameObject OBJ = gameObjectsByName.get(NAME);
        if (OBJ == null)
        {
            Logger.FORGE_LOG_WARNING("Found no game object with Name: " + NAME + " in scene: " + this);
        }
        return OBJ;
    }

    public void clearGameObjects()
    {
        for (GameObject obj : gameObjectsById.values())
        {
            obj.destroy();
        }
        gameObjectsById.clear();
        gameObjectsByName.clear();
    }

    // - - - Getters and Setters - - -

    public Camera getCamera()
    {
        return this.camera;
    }

    // - - - Editor GUI
    public void editorGUI()
    {
        this.script.editorGUI();
    }


    public void editorUpdate(float DELTA_TIME)
    {
        this.script.editorUpdate(DELTA_TIME);

        updateKernel(DELTA_TIME);
    }


    public List<GameObject> getGameObjects()
    {
        // Return a list of all game objects in the map
        return (List<GameObject>) gameObjectsById.values();
    }

    public List<GameObject> getGameObjects(List<Class<? extends Component>> TYPES)
    {
        if (TYPES.isEmpty()) return getGameObjects();

        List<GameObject> returnList = new ArrayList<>();
        for (GameObject go : gameObjectsById.values())
        {
            boolean matches = false;
            for (Class<? extends Component> type : TYPES)
            {
                if (go.hasComponent(type))
                {
                    matches = true;
                    break;
                }
            }
            if (matches)
            {
                returnList.add(go);
            }
        }
        return returnList;
    }

    public List<GameObject> getGameObjects(String NAME)
    {
        if (NAME.isEmpty() || NAME.isBlank()) return getGameObjects();

        String searchName = NAME.trim().toLowerCase();
        List<GameObject> returnList = new ArrayList<>();
        for (GameObject go : gameObjectsByName.values())
        {
            if (go.name.toLowerCase().startsWith(searchName))
            {
                returnList.add(go);
            }
        }
        return returnList;
    }

    public List<GameObject> getGameObjects(List<Class<? extends Component>> TYPES, String NAME)
    {
        if (TYPES.isEmpty()) return getGameObjects(NAME);
        if (NAME.isEmpty() || NAME.isBlank()) return getGameObjects(TYPES);

        String searchName = NAME.trim().toLowerCase();
        List<GameObject> returnList = new ArrayList<>();
        for (GameObject go : gameObjectsById.values())
        {
            boolean matchesType = false;
            for (Class<? extends Component> type : TYPES)
            {
                if (go.hasComponent(type))
                {
                    matchesType = true;
                    break;
                }
            }
            if (matchesType && go.name.toLowerCase().startsWith(searchName))
            {
                returnList.add(go);
            }
        }
        return returnList;
    }



    public PhysicsSystemManager getPhysics()
    {
        return this.physics;
    }

    @Override
    public String toString()
    {
        return this.name;
    }

    public String getSavePath()
    {
        return this.savePath;
    }

    public void setSavePath(String PATH)
    {
        this.savePath = PATH;
    }

    public Renderer getRenderer()
    {
        return this.renderer;
    }

    public SceneScript getScript()
    {
        return this.script;
    }

}