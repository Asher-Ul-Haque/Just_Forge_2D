package Just_Forge_2D.SceneSystem;

import Just_Forge_2D.AnimationSystem.AnimationComponent;
import Just_Forge_2D.AssetPool.AssetPool;
import Just_Forge_2D.EditorSystem.EditorSystemManager;
import Just_Forge_2D.EntityComponentSystem.Components.Component;
import Just_Forge_2D.EntityComponentSystem.Components.SpriteComponent;
import Just_Forge_2D.EntityComponentSystem.Components.TransformComponent;
import Just_Forge_2D.EntityComponentSystem.GameObject;
import Just_Forge_2D.EventSystem.EventManager;
import Just_Forge_2D.InputSystem.Mouse;
import Just_Forge_2D.PhysicsSystem.PhysicsComponents.RigidBodyComponent;
import Just_Forge_2D.PhysicsSystem.PhysicsSystemManager;
import Just_Forge_2D.RenderingSystem.Renderer;
import Just_Forge_2D.Utils.Logger;

import java.util.*;

// - - - Abstract class for all the scenes
public class Scene
{
    // - - - Private Variables - - -

    // - - - Basic
    private Camera camera;
    private String savePath = "";
    protected boolean isRunning = false;

    // - - - ALl the objects
    private final List<GameObject> gameObjects;
    private final Map<Integer, GameObject> gameObjectsById = new HashMap<>();
    private final Map<String, GameObject> gameObjectsByName = new HashMap<>();
    private final Set<GameObject> pendingObjects = new HashSet<>();

    // - - - Scene Rendering
    private final Renderer renderer;
    private final SceneScript script;

    // - - - saving and loading
    private final PhysicsSystemManager physics;

    private final String name;


    // - - - | Functions | - - -


    // - - - Now presenting: useful constructor
    public Scene(SceneScript INITIALIZER, String NAME)
    {
        this.script = INITIALIZER;
        this.physics = new PhysicsSystemManager(this, INITIALIZER.physicsWorld);
        this.renderer = INITIALIZER.renderer;
        this.gameObjects = new ArrayList<>();
        this.isRunning = false;
        this.name = NAME;
    }


    // - - - Use the Scene - - -

    public void start()
    {
        Logger.FORGE_LOG_INFO("Starting Scene : " + this.script);
        for (GameObject go : gameObjectsById.values())
        {
            // - - - Register with renderer and physics if applicable
            if (this.renderer != null && go.hasComponent(SpriteComponent.class))
            {
                this.renderer.add(go);
            }
            if (this.physics != null && go.hasComponent(RigidBodyComponent.class))
            {
                this.physics.add(go);
            }

            // - - - Start the game object
            go.start();
        }
        isRunning = true;
        Logger.FORGE_LOG_INFO("Scene: " + this + " Started");
    }



    public void update(float DELTA_TIME)
    {
        if (!this.isRunning) return;

        this.script.update(DELTA_TIME);
        if (this.physics != null) this.physics.update(DELTA_TIME);

        this.camera.adjustProjection();

        // - - - Update objects and remove dead ones
        gameObjectsById.values().removeIf(go ->
        {
            go.update(DELTA_TIME);
            boolean isDead = go.isDead();
            if (isDead)
            {
                if (physics != null) physics.destroyGameObject(go);
                if (renderer != null) renderer.destroyGameObject(go);
                gameObjectsByName.remove(go.name);
            }
            return isDead;
        });

        // - - - Add pending objects to the active pool
        for (GameObject go : pendingObjects)
        {
            gameObjectsById.put(go.getUniqueID(), go);
            gameObjectsByName.put(go.name, go);
            go.start();
            if (renderer != null && go.hasComponent(SpriteComponent.class)) renderer.add(go);
            if (physics != null && go.hasComponent(RigidBodyComponent.class)) physics.add(go);
        }
        pendingObjects.clear();
    }

    public void render(float DELTA_TIME)
    {
        if (this.renderer != null) this.renderer.render();
        this.script.render(DELTA_TIME);
    }

    public void init()
    {
        this.camera = Mouse.getWorldCamera();
        if (!EditorSystemManager.isRelease)
        {
            addGameObject(SceneSystemManager.createMaster(this));
            //this.gameObjects.add(0, SceneSystemManager.createMaster(this));
        }
        EventManager.addObserver(this.camera);
        if (this.savePath.isEmpty()) setSavePath(this.script.savePath);
        this.script.loadResources(this);
        for (GameObject g : this.getGameObjects())
        {
            if (g.getComponent(SpriteComponent.class) != null)
            {
                SpriteComponent spr = g.getComponent(SpriteComponent.class);
                if (spr.getTexture() != null)
                {
                    spr.setTexture(AssetPool.makeTexture(spr.getTexture().getFilepath()));
                }
            }

            if (g.getComponent(AnimationComponent.class) != null)
            {
                AnimationComponent stateMachine = g.getComponent(AnimationComponent.class);
                stateMachine.refreshTextures();
            }
        }
        this.script.init(this);
        Logger.FORGE_LOG_INFO("Scene: " + this.script + " Initialized");
    }


    // - - -  Game Objects - - -

    public GameObject createGameObject(String NAME)
    {
        GameObject go = new GameObject(NAME);
        go.addComponent(new TransformComponent());
        go.transform = go.getComponent(TransformComponent.class);
        return go;
    }

    public void addGameObject(GameObject GAME_OBJECT)
    {
        if (isRunning)
        {
            pendingObjects.add(GAME_OBJECT);
        }
        else
        {
            gameObjectsById.put(GAME_OBJECT.getUniqueID(), GAME_OBJECT);
            gameObjectsByName.put(GAME_OBJECT.name, GAME_OBJECT);
        }
    }

    public void addGameObjectIfNotPresent(GameObject GAME_OBJECT)
    {
        if (pendingObjects.contains(GAME_OBJECT) || gameObjects.contains(GAME_OBJECT)) return;
        addGameObject(GAME_OBJECT);
    }

    public GameObject getGameObject(int GAME_OBJECT_ID)
    {
        return gameObjectsById.get(GAME_OBJECT_ID);
    }

    public GameObject getGameObject(String NAME)
    {
        for (GameObject object : gameObjects)
        {
            if (object.name.equals(NAME))
            {
                return object;
            }
        }
        Logger.FORGE_LOG_WARNING("Found no game object with Name: " + NAME + " in scene: " + this);
        return null;
    }

    public void clearGameObjects()
    {
        for (int i = 1; i < gameObjects.size(); ++i)
        {
            gameObjects.get(i).destroy();
        }
    }

    // - - - Getters and Setters - - -

    public Camera getCamera()
    {
        return this.camera;
    }

    // - - - Editor GUI
    public void editorGUI()
    {
        this.script.editorGUI();
    }


    public void editorUpdate(float DELTA_TIME)
    {
        this.script.editorUpdate(DELTA_TIME);
        this.camera.adjustProjection();

        // - - - Update objects and remove dead ones
        gameObjectsById.values().removeIf(go ->
        {
            go.editorUpdate(DELTA_TIME);
            boolean isDead = go.isDead();
            if (isDead)
            {
                if (physics != null) physics.destroyGameObject(go);
                if (renderer != null) renderer.destroyGameObject(go);
                gameObjectsByName.remove(go.name);
            }
            return isDead;
        });

        // - - - Add pending objects to the active pool
        for (GameObject go : pendingObjects)
        {
            gameObjectsById.put(go.getUniqueID(), go);
            gameObjectsByName.put(go.name, go);
            go.start();
            if (renderer != null && go.hasComponent(SpriteComponent.class)) renderer.add(go);
            if (physics != null && go.hasComponent(RigidBodyComponent.class)) physics.add(go);
        }
        pendingObjects.clear();
    }


    public List<GameObject> getGameObjects()
    {
        return new ArrayList<>(this.gameObjectsById.values());
    }

    public List<GameObject> getGameObjects(List<Class<? extends Component>> TYPES)
    {
        if (TYPES.isEmpty()) return getGameObjects();
        List<GameObject> returnList = new ArrayList<>();
        for (GameObject g : this.gameObjects)
        {
            boolean added = false;
            for (Class<? extends Component> type : TYPES)
            {
                if (g.hasComponent(type) && !added)
                {
                    returnList.add(g);
                    added = true;
                }
            }
        }
        return returnList;
    }

    public List<GameObject> getGameObjects(String NAME)
    {
        if (NAME.isEmpty() || NAME.isBlank()) return getGameObjects();
        List<GameObject> returnList = new ArrayList<>();
        for (GameObject g : this.gameObjects)
        {
            if (g.toString().trim().toLowerCase().startsWith(NAME.toLowerCase().trim())) returnList.add(g);
        }
        return returnList;
    }

    public List<GameObject> getGameObjects(List<Class<? extends Component>> TYPES, String NAME)
    {
        if (TYPES.isEmpty()) return getGameObjects(NAME);
        if (NAME.isEmpty() || NAME.isBlank()) return getGameObjects(TYPES);

        List<GameObject> returnList = new ArrayList<>();
        for (GameObject g : this.gameObjects)
        {
            boolean added = false;
            for (Class<? extends Component> type : TYPES)
            {
                if (g.hasComponent(type) && g.toString().trim().toLowerCase().startsWith(NAME.toLowerCase().trim()) && !added)
                {
                    returnList.add(g);
                    added = true;
                }
            }
        }
        return returnList;
    }


    public PhysicsSystemManager getPhysics()
    {
        return this.physics;
    }

    @Override
    public String toString()
    {
        return this.name;
    }

    public String getSavePath()
    {
        return this.savePath;
    }

    public void setSavePath(String PATH)
    {
        this.savePath = PATH;
    }

    public Renderer getRenderer()
    {
        return this.renderer;
    }

    public SceneScript getScript()
    {
        return this.script;
    }
}